<?xml version="1.0"?>
<!-- This file is part of the book                 -->
<!--                                               -->
<!--   Abstract Algebra: Theory and Applications   -->
<!--                                               -->
<!-- Copyright (C) 2010-2014  Robert A. Beezer     -->
<!-- See the file COPYING for copying conditions.  -->
<!--                                               -->
<!-- This file is automatically generated from the -->
<!-- private solution manual.  Minor contributed   -->
<!-- edits can be made against this file for       -->
<!-- the purpose of a pull request.                -->
<exercises xml:id="algcodes-sage-exercises">
    <title>Sage Exercises</title>

    <exercise number="1">
        <statement>
            <p>Create the (binary) Golay code with the <c>codes.BinaryGolayCode()</c> constructor.</p>

            <ol>
                <li>Use Sage methods to compute the length, dimension and minimum distance of the code.</li>
                <li>How many errors can this code detect?  How many can it correct?</li>
                <li>Find a nonzero codeword and introduce three errors by adding a vector with three 1's (your choice) to create a received message.  Show that the message is decoded properly.</li>
                <li>Recycle your choices from the previous part, but now add one more error.  Does the new received message get decoded properly?</li>
            </ol>
        </statement>
        
    </exercise>

    <exercise number="2">
        <statement>
            <p>One technique for improving the characteristics of a code is to add an overall parity-check bit, much like the lone parity-check bit of the <acro>ASCII</acro> code described in Example<nbsp/><xref ref="example-algcodes-even-parity"/>.  Such codes are referred to as the <term>extended</term> version of the original.</p>

            <ol>
                <li>
                    <p>Construct the (binary) Golay code and obtain the parity-check matrix.  Use Sage commands to enlarge this matrix to create a new parity check matrix that has an additional overall parity-check bit.  You may find the matrix methods <c>.augment()</c> and <c>.stack()</c> useful, as well as the constructors <c>zero_vector()</c> and <c>ones_matrix()</c> (remembering that we specify the binary entries as being from the field <c>GF(2)</c>.)</p>

                    <p>Create the extended code by supplying your enlarged parity-check matrix to the <c>codes.LinearCodeFromCheckMatrix()</c> constructor and compute the length, dimension and minimum distance of the extended code.</p>
                </li>

                <li>How are the properties of this new code better?  At what cost?</li>

                <li>Now create the extended (binary) Golay code with the Sage constructor <c>codes.ExtendedBinaryGolayCode()</c>.  With luck, the sorted lists of your codewords and Sage's codewords will be equal.  If not, the linear code method <c>.is_permutation_equivalent()</c> should return <c>True</c> to indicate that your code and Sage's are just rearrangements of each other.</li>
            </ol>
        </statement>
        
    </exercise>

    <exercise number="3">
        <statement>
            <p><em>Note:</em> This problem is on holiday (as of Sage 6.7), while some buggy Sage code for the minimum distance of a Hamming code gets sorted out.  The <c>r = 2</c> case produces an error message and for <c>r &gt; 5</c> the computation of the minimum distance has become intolerably slow.  So it is a bit harder to make a reasonable conjecture from just <m>3</m> cases.</p>

            <p>The dual of an <m>(n,k)</m> block code is formed as all the set of all binary vectors which are orthogonal to every vector of the original code.  Exercise<nbsp/><xref ref="exercise-algcodes-dual-code"/> describes this construction and asks about some of its properties.</p>

            <p>You can construct the dual of a code in Sage with the <c>.dual_code()</c> method.  Construct the binary Hamming codes, and their duals, with the parameter <c>r</c> ranging from <c>2</c> to <c>10</c>, inclusive.  Build a table with six columns (perhaps employing the <c>html.table()</c> function) that lists <m>r</m>, the length of the codes, the dimensions of the original and the dual, and the minimum distances of the orginal and the dual.</p>

            <p>Conjecture formulas for the dimension and minimum distance of the dual of the Hamming code as expressions in the parameter <m>r</m>.</p>
        </statement>
        
    </exercise>

    <exercise number="4">
        <statement>
            <p>A code with minimum distance <m>d</m> is called <term>perfect</term> if every possible vector is within Hamming distance <m>(d-1)/2</m> of some codeword.  If we expand our notion of geometry to account for the Hamming distance as the metric, then we can speak of a sphere of radius <m>r</m> around a vector (or codeword.  For a code of length <m>n</m>, such a sphere will contain <me>1 + {n\choose 1} + {n\choose 2} + \cdots + {n\choose r}</me> vectors within in it.  For a perfect code, the spheres of radius <m>d</m> centered at the codewords of the code will exactly partition the entire set of all possible vectors.  (This is the connection that means that coding theory meshes with sphere packing problems.)</p>

            <p>A consequence of a code of dimension <m>k</m> being perfect is that <me>2^k\left({n\choose 0} + {n\choose 1} + {n\choose 2} + \cdots + {n\choose \frac{d-1}{2}}\right) = 2^n</me>  Conversely, if a code has minimum distance <m>d</m> and the condition above is true, then the code is perfect.</p>

            <p>Write a Python function, named <c>is_perfect()</c> which accepts a linear code as input and returns <c>True</c> or <c>False</c>.  Demonstrate your function by checking that the (binary) Golay code is perfect, and then use a loop to verify that the (binary) Hamming codes are perfect for all lengths below <m>32</m>.</p>
        </statement>
        
    </exercise>

    <!-- Potential exercise 5: probabilty and Shannon bound -->
</exercises>
