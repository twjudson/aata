<?xml version="1.0"?>
<!-- This file is part of the book                 -->
<!--                                               -->
<!--   Abstract Algebra: Theory and Applications   -->
<!--                                               -->
<!-- Copyright (C) 2010-2014  Robert A. Beezer     -->
<!-- See the file COPYING for copying conditions.  -->
<!--                                               -->
<!-- This file is automatically generated from the -->
<!-- private solution manual.  Minor contributed   -->
<!-- edits can be made against this file for       -->
<!-- the purpose of a pull request.                -->
<exercises xml:id="cosets-sage-exercises">
	<title>Sage Exercises</title>

	<introduction>
		<p>The following exercises are less about cosets and subgroups, and more about using Sage as an experimental tool.  They are designed to help you become both more efficient, and more expressive, as you write commands in Sage.  We will have many opportunities to work with cosets and subgroups in the coming chapters.  These exercises do not contain much guidance, and get more challenging as they go.  They are designed to explore, or confirm, results presented in this chapter or earlier chapters.</p>

		<p><alert>Important</alert>: You should answer each of the last three problems with a single (complicated) line of Sage that concludes by outputting <c>True</c>.  A <q>single line</q> means you will have several Sage commands packaged up together in complicated ways.  It does not mean several Sage commands seperated by semi-colons and typed in on a single line.  Be sure include some intermediate steps used in building up your solution, but using smaller ranges of values so as to not overwhelm the reader with lots of output.  This will help you, and the grader of your work, have some confidence that the final version is correct.</p>

		<p>When you check integers below for divisibility, remember that <c>range()</c> produces plain integers, which are quite simple in their functionality.  The <c>srange()</c> command produces Sage integers, which have many more capabilities.  (See the last exercise for an example.)  And remember that a list comprehension is a very compact way to examine many possibilities at once.</p>
	</introduction>


	<exercise number="1">
		<statement>
			<p>Use <c>.subgroups()</c> to find an example of a group <m>G</m> and an integer <m>m</m>, so that (a) <m>m</m> divides the order of <m>G</m>, and (b) <m>G</m> has no subgroup of order <m>m</m>.  (Do not use the group <m>A_4</m> for <m>G</m>, since this is in the text.)  Provide a single line of Sage code that has all the logic to produce the desired <m>m</m> as its output.  (You can give your group a simple name on a prior line and then just reference the group by name.)  Here is a very simple example that might help you structure your answer.</p>

			<sage>
				<input>
				a = 5
				b = 10
				c = 6
				d = 13
				a.divides(b)
				</input>
				<output>True</output>
			</sage>

			<sage>
				<input>not (b in [c,d])</input>
				<output>True</output>
			</sage>

			<sage>
				<input>a.divides(b) and not (b in [c,d])</input>
				<output>True</output>
			</sage>

		</statement>
		
	</exercise>

	<exercise number="2">
		<statement>
			<p>Verify the truth of Fermat's Little Theorem (either variant) using the composite number <m>391=17\cdot 23</m> as the choice of the base (either <m>a</m> or <m>b</m>), and for <m>p</m> assuming the value of every prime number between <m>100</m> and <m>1000</m>.</p>

			<p>Build up a solution slowly <mdash/> make a list of powers (start with just a few primes), then make a list of powers reduced by modular arithmetic, then a list of comparisons with the predicted value, then a check on all these logical values resulting from the comparisons.  This is a useful strategy for many similar problems.  Eventually you will write a single line that performs the verification by eventually printing out <c>True</c>.  Here are some more hints about useful functions.</p>

			<sage>
				<input>
				a = 20
				b = 6
				a.mod(b)
				</input>
				<output>2</output>
			</sage>

			<sage>
				<input>prime_range(50, 100)</input>
				<output>[53, 59, 61, 67, 71, 73, 79, 83, 89, 97]</output>
			</sage>

			<sage>
				<input>all([True, True, True, True])</input>
				<output>True</output>
			</sage>

			<sage>
				<input>all([True, True, False, True])</input>
				<output>False</output>
			</sage>

		</statement>
		
	</exercise>

	<exercise number="3">
		<statement>
			<p>Verify that the group of units mod <m>n</m> has order <m>n-1</m> when <m>n</m> is prime, again for all primes between <m>100</m> and <m>1000</m>.  As before, your output should be simply <c>True</c>, just once, indicating that the statement about the order is true for all the primes examined.  As before, build up your solution slowly, and with a smaller range of primes in the beginning.  Express your answer as a single line of Sage code.</p>
		</statement>
		
	</exercise>

	<exercise number="4">
		<statement>
			<p>Verify Euler's Theorem for all values of <m>0\lt n\lt 100</m> and for <m>1\leq a \leq n</m>.  This will require nested <c>for</c> statements with a conditional.  Again, here is a small example that might be helpful for constructing your one line of Sage code.  Note the use of <c>srange()</c> in this example.</p>

			<sage>
				<input>[a/b for a in srange(9) for b in srange(1,a) if gcd(a,b)==1]</input>
				<output>
				[2, 3, 3/2, 4, 4/3, 5, 5/2, 5/3, 5/4, 6, 6/5,
				 7, 7/2, 7/3, 7/4, 7/5, 7/6, 8, 8/3, 8/5, 8/7]
				</output>
			</sage>

		</statement>
		
	</exercise>

	<exercise number="5">
		<statement>
			<p>The symmetric group on <m>7</m> symbols, <m>S_7</m>, has <m>7! = 5040</m> elements.  Consider the following questions without employing Sage, based on what we know about orders of elements of permutation groups (Exercise<nbsp/><xref ref="exercise-permute-order-product-cycles"/>).</p>

			<ul>
				<li><p>What is the maximum possible order?</p></li>
				<li><p>How many elements are there of order <m>10</m>?</p></li>
				<li><p>How many elements are there of order <m>1</m>?</p></li>
				<li><p>How many elements are there of order <m>2</m>?</p></li>
				<li><p>What is the smallest positive integer for which there is no element with that order?</p></li>
			</ul>

			<p>These questions will be easier if you are familiar with using binomial coefficients for counting in similarly complex situations.  But either way, give some serious thought to each question (and maybe a few of your own) before firing up Sage.</p>

			<p>Now, compute how many elements there are of each order using the <c>.order()</c> method, and then embed this into a list comprehension which creates a single list of these counts.  You can check your work (or check Sage) by wrapping this list in <c>sum()</c> and hopefully getting <m>5040</m>.</p>

			<p>Comment on the process of studying these questions first without any computational aid, and then again with Sage.  For which values of <m>n</m> do you think Sage would be too slow and your mind quicker?</p>
		</statement>
		
	</exercise>

</exercises>
